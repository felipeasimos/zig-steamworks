const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process');

const [nodeBinary, jsFile, json] = process.argv

if (!json || !json.endsWith('steam_api.json')) {
  throw new Error(`Please provide a path to steam_api.json as first argument`)
}

const data = require(path.resolve(json));

const outFile = 'src/steam.zig'
const outFileCpp = 'src/steam.cpp'

const cpp = [
  '// this file is autogenerated by generate.js - https://github.com/menduz/zig-steamworks',
  `#import "steam_api.h"`,
  `#import "steam_gameserver.h"`,
  ``,
  `extern "C" void* CustomSteamClientGetter() { return SteamClient(); }`
]

const out = ['// this file is autogenerated by generate.js - https://github.com/menduz/zig-steamworks']

out.push(`pub const CGameID = u64;`)
out.push(`pub const CSteamID = u64;`)
out.push(`pub const intptr_t = anyopaque;`)
out.push(`pub const size_t = isize;`)
out.push(`pub const SteamAPIWarningMessageHook_t = ${convertType(`void (*)(int, const char *)`)};`)
out.push(`pub const SteamAPI_CheckCallbackRegistered_t = ${convertType(`void (*)(int)`)};`)
out.push(`pub const SteamDatagramRelayAuthTicket = ?*anyopaque;`)
out.push(`pub const ISteamNetworkingConnectionSignaling = ?*anyopaque;`)
out.push(`pub const ISteamNetworkingSignalingRecvContext = ?*anyopaque;`)

out.push(`
/// SteamAPI_Init must be called before using any other API functions. If it fails, an
/// error message will be output to the debugger (or stderr) with further information.
pub extern fn SteamAPI_Init() callconv(.C) bool;

/// SteamAPI_Shutdown should be called during process shutdown if possible.
pub extern fn SteamAPI_Shutdown() callconv(.C) void;

// SteamAPI_RestartAppIfNecessary ensures that your executable was launched through Steam.
//
// Returns true if the current process should terminate. Steam is now re-launching your application.
//
// Returns false if no action needs to be taken. This means that your executable was started through
// the Steam client, or a steam_appid.txt file is present in your game's directory (for development).
// Your current process should continue if false is returned.
//
// NOTE: If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary
// since the DRM wrapper will ensure that your application was launched properly through Steam.
pub extern fn SteamAPI_RestartAppIfNecessary( unOwnAppID: u32 ) callconv(.C) bool;

// Many Steam API functions allocate a small amount of thread-local memory for parameter storage.
// SteamAPI_ReleaseCurrentThreadMemory() will free API memory associated with the calling thread.
// This function is also called automatically by SteamAPI_RunCallbacks(), so a single-threaded
// program never needs to explicitly call this function.
pub extern fn SteamAPI_ReleaseCurrentThreadMemory() callconv(.C) void;


// crash dump recording functions
//pub extern fn SteamAPI_WriteMiniDump( uint32 uStructuredExceptionCode, void* pvExceptionInfo, uint32 uBuildID ) callconv(.C) void;
//pub extern fn SteamAPI_SetMiniDumpComment( const char *pchMsg ) callconv(.C) void;

//----------------------------------------------------------------------------------------------------------------------------------------------------------//
//	steamclient.dll private wrapper functions
//
//	The following functions are part of abstracting API access to the steamclient.dll, but should only be used in very specific cases
//----------------------------------------------------------------------------------------------------------------------------------------------------------//

/// SteamAPI_IsSteamRunning() returns true if Steam is currently running
pub extern fn SteamAPI_IsSteamRunning() callconv(.C) bool;

/// sets whether or not Steam_RunCallbacks() should do a try {} catch (...) {} around calls to issuing callbacks
/// This is ignored if you are using the manual callback dispatch method
pub extern fn SteamAPI_SetTryCatchCallbacks( bTryCatchCallbacks: bool ) callconv(.C) void;

/// Inform the API that you wish to use manual event dispatch.  This must be called after SteamAPI_Init, but before
/// you use any of the other manual dispatch functions below.
pub extern fn SteamAPI_ManualDispatch_Init() callconv(.C) void;

/// Perform certain periodic actions that need to be performed.
pub extern fn SteamAPI_ManualDispatch_RunFrame(hSteamPipe: HSteamPipe) callconv(.C) void;

/// Internal structure used in manual callback dispatch
pub const CallbackMsg_t = extern struct  {
  /// Specific user to whom this callback applies.
	m_hSteamUser: HSteamUser,
	// Callback identifier.  (Corresponds to the k_iCallback enum in the callback structure.)
  m_iCallback: i32,
  /// Points to the callback structure
	m_pubParam: *u8,
  /// Size of the data pointed to by m_pubParam
	m_cubParam: i32,
};

/// Fetch the next pending callback on the given pipe, if any.  If a callback is available, true is returned
/// and the structure is populated.  In this case, you MUST call SteamAPI_ManualDispatch_FreeLastCallback
/// (after dispatching the callback) before calling SteamAPI_ManualDispatch_GetNextCallback again.
pub extern fn SteamAPI_ManualDispatch_GetNextCallback(hSteamPipe: HSteamPipe, pCallbackMsg: [*c]CallbackMsg_t) callconv(.C) bool;

/// You must call this after dispatching the callback, if SteamAPI_ManualDispatch_GetNextCallback returns true.
pub extern fn SteamAPI_ManualDispatch_FreeLastCallback(hSteamPipe: HSteamPipe) callconv(.C) void;

/// Return the call result for the specified call on the specified pipe.  You really should
/// only call this in a handler for SteamAPICallCompleted_t callback.
pub extern fn SteamAPI_ManualDispatch_GetAPICallResult(hSteamPipe: HSteamPipe, hSteamAPICall: SteamAPICall_t, pCallback: *const fn() void,  cubCallback: i32, iCallbackExpected: i32, pbFailed: *bool) void;

extern fn CustomSteamClientGetter() callconv(.C) [*c]ISteamClient;
pub fn SteamClient() ISteamClient {
  return ISteamClient{ .ptr = CustomSteamClientGetter() };
}
`)

out.push(`\n// Typedefs`)
data.typedefs.forEach(t => {
  out.push(`pub const ${t.typedef} = ${convertType(t.type)};`)
})

out.push(`\n// Callbacks`)
data.callback_structs.forEach(_ => {
  out.push(`/// callbackId = ${_.callback_id}`)
  printStruct(_)
})

printConsts(data.consts);
function printConsts(list) {
  out.push(`\n// Constants`)
  list.forEach(_ => {
    switch (_.constname) {
      case 'k_SteamDatagramPOPID_dev':
      case 'k_SteamItemInstanceIDInvalid':
        return out.push(`// TODO: fix the next line declaration\n// pub const ${_.constname}: ${convertType(_.consttype)} = ${_.constval};`)
    }

    const val = _.constval === '0xffffffffffffffffull' ? '0xffffffffffffffff' : _.constval

    return out.push(`pub const ${_.constname}: ${convertType(_.consttype)} = ${val}; `)
  })
}

function getDefaultValue(typeName, internalType) {
  const enums = [...data.enums, ...(internalType?.enums ?? [])]
  const isEnum = enums.find($ => $.enumname == typeName)
  if (isEnum) {
    const zero = isEnum.values.find($ => parseInt($.value) === 0)
    if (zero) {
      return `${typeName}.${zero.name}`
    }
  }

  switch (typeName) {
    case 'bool': return false
    case 'u8':
    case 'u8':
    case 'i8':
    case 'i16':
    case 'u16':
    case 'i32':
    case 'u32':
    case 'i64':
    case 'u64':
    case 'f32':
    case 'f64':
    case 'c_int':
    case 'isize':
    case 'usize':
    case 'c_uint':
    case 'c_int':
      return '0'
    case '?*anyopaque':
    case '?*const anyopaque':
    case '[*c]u8':
    case '[*c]const u8':
    case '[*c][*c]const u8':
    case '*const anyopaque':
      return 'null'
  }

  const isTypedef = data.typedefs.find($ => $.typedef == typeName)

  if (isTypedef) {
    return getDefaultValue(convertType(isTypedef.type), internalType)
  }
}

function printEnums(enums) {
  enums.length && out.push(`\n// Enums`)
  enums.forEach(_ => {
    const typename = `${_.enumname}`
    out.push(`\npub const ${typename} = enum(c_int) {`)

    _.values.forEach(_ => {
      out.push(`${_.name} = ${_.value},`)
    })

    out.push(`};`)
  })
}

printEnums(data.enums)

function printStructMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = _.params.map(p =>
        `${paramName(p.paramname)}: ${convertType(p.paramtype)}`
      )

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: *Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['@ptrCast(?*anyopaque, self)', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function printMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = _.params.map(p =>
        `${paramName(p.paramname)}: ${convertType(p.paramtype)}`
      )

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['self.ptr', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function printMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = _.params.map(p =>
        `${paramName(p.paramname)}: ${convertType(p.paramtype)}`
      )

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['self.ptr', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function paramName(p) {
  switch (p) {
    case "type":
      return '_type'
  } return p
}

function printFns(structName, data) {
  if (data && data.length) {
    out.push(`\n// static functions`)
    data.forEach(_ => {
      const self = `self: ?*anyopaque`

      const originalParams = _.params.map(p =>
        `${paramName(p.paramname)}: ${convertType(p.paramtype)}`
      )

      const params = [
        self,
        ...originalParams
      ]

      out.push(`extern fn ${_.methodname_flat}(${params.join(', ')}) callconv(.C) ${convertType(_.returntype)};`)
    })
  }
}

function printStruct(struct) {
  const structName = struct.struct;
  out.push(`pub const ${structName} = extern struct {`)

  struct.fields.forEach(_ => {
    const type = convertType(_.fieldtype)
    const val = getDefaultValue(type, struct)
    out.push(`  ${_.fieldname}: ${convertType(_.fieldtype)} ${val !== undefined ? '=' + val : ''},`)
  });

  struct.consts && printConsts(struct.consts);
  struct.enums && printEnums(struct.enums)

  printStructMethods(structName, struct.methods)

  out.push('};')
  printFns(structName, struct.methods)
}

out.push(`\n// Structs`)
data.structs.forEach(printStruct)

out.push(`\n// Interfaces`)

data.interfaces.forEach(_ => {

  _.accessors?.forEach(a => {
    out.push(`extern fn ${a.name_flat}() callconv(.C) [*c]${_.classname};`)

    out.push(`/// ${a.kind}`)
    out.push(`pub fn ${a.name}() ${_.classname} {`)
    out.push(`  return ${_.classname}{ .ptr = ${a.name_flat}() };`)
    out.push(`}`)
  })


  out.push(`\npub const ${_.classname} = extern struct {`)
  out.push(`ptr: ?*anyopaque,`)

  _.enums && printEnums(_.enums)
  printMethods(_.classname, _.methods)
  out.push('};')
  printFns(_.classname, _.methods)
})

function convertType(t) {
  if (t === undefined) return ''

  if (t && t.startsWith('void (*)')) {
    const middle = /\(([^\(]*)\)$/.exec(t)
    const types = middle ? middle[1].split(/\s*,\s*/g) : []
    return `?*const fn (${types.map(convertType).join(',')}) callconv(.C) void`

  }

  { // char[123]
    const slice = /([a-z0-9_]+)\s*\[(\d+)\]/i
    const r = slice.exec(t)
    if (r) {
      return `[${r[2]}]${convertType(r[1])}`
    }
  }
  switch (t) {
    case 'char': return 'u8';
    case 'unsigned char': return 'u8';
    case 'signed char': return 'i8';
    case 'short': return 'i16';
    case 'unsigned short': return 'u16';
    case 'int': return 'i32';
    case 'int32_t': return 'i32';
    case 'unsigned int': return 'u32';
    case 'long long': return 'i64';
    case 'int64_t': return 'i64';
    case 'unsigned long long': return 'u64';
    case 'void *': return '?*anyopaque';
    case 'const void *': return '?*const anyopaque';
    case 'char *': return '[*c]u8'
    case 'float': return 'f32'
    case 'double': return 'f64'
    case 'const char *': return '[*c]const u8'
    case 'const char **': return '[*c][*c]const u8'
    case 'SteamInputActionEvent_t::AnalogAction_t': return 'SteamInputActionEvent_t'
    case 'RequestPlayersForGameResultCallback_t::PlayerAcceptState_t': return 'c_int'

    case 'const ScePadTriggerEffectParam *':
      return '*const anyopaque'

    case 'ISteamHTMLSurface::EHTMLMouseButton':
    case 'ISteamHTMLSurface::EHTMLKeyModifiers':
      return 'c_int'
  }

  if (data.enums.some(_ => _.enumname === t))
    return `${t}`;
  { // const servernetadr_t *
    const slice = /^const ([0-9a-z_]+)\s*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]const ${convertType(r[1])}`
    }
  }
  { // servernetadr_t *const*
    const slice = /([0-9a-z_]+)\s*\*\s?const\s?\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]const [*c] ${convertType(r[1])}`
    }
  }
  { // servernetadr_t **
    const slice = /^([0-9a-z_]+)\s*\*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c][*c] ${convertType(r[1])}`
    }
  }
  { //const servernetadr_t &
    const slice = /^const ([0-9a-z_]+)\s*&$/i
    const r = slice.exec(t)
    if (r) {
      return `${convertType(r[1])}`
    }
  }
  { //servernetadr_t &
    const slice = /^([0-9a-z_]+)\s*&$/i
    const r = slice.exec(t)
    if (r) {
      return `${convertType(r[1])}`
    }
  }
  { // servernetadr_t *
    const slice = /^([0-9a-z_]+)\s*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]${convertType(r[1])}`
    }
  }
  return t;
}

fs.writeFileSync(outFile, out.join('\n'))
fs.writeFileSync(outFileCpp, cpp.join('\n'))