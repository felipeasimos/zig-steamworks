const fs = require('fs')
const path = require('path')

const [nodeBinary, jsFile, json] = process.argv

if (!json || !json.endsWith('steam_api.json')) {
  throw new Error(`Please provide a path to steam_api.json as first argument`)
}

const data = require(path.resolve(json));

const outFile = 'src/steam.zig'
const outFileCpp = 'src/steam.cpp'

const cpp = [
  '// this file is autogenerated by generate.js - https://github.com/menduz/zig-steamworks',
  `#import "steam_api.h"`,
  `#import "steam_gameserver.h"`,
  ``,
  `extern "C" void* CustomSteamClientGetter() { return SteamClient(); }`
]


const g_CustomPackSize = {
  // Callbacks
  "AvatarImageLoaded_t": "4",
  "FriendRichPresenceUpdate_t": "4",
  "GameConnectedClanChatMsg_t": "4",
  "GameConnectedChatLeave_t": "1",
  "JoinClanChatRoomCompletionResult_t": "4",
  "GameConnectedFriendChatMsg_t": "4",
  "FriendsGetFollowerCount_t": "4",
  "FriendsIsFollowing_t": "4",
  "FriendsEnumerateFollowingList_t": "4",
  "GSClientDeny_t": "4",
  "GSClientKick_t": "4",
  "GSClientGroupStatus_t": "1",
  "GSStatsReceived_t": "4",
  "GSStatsStored_t": "4",
  "P2PSessionConnectFail_t": "1",
  "SocketStatusCallback_t": "4",
  "ValidateAuthTicketResponse_t": "4",

  // Structs
  "InputAnalogActionData_t": "1",
  "InputDigitalActionData_t": "1",
}


// cleanup
{
  data.callback_structs = data.callback_structs.filter($ => {
    if ($.struct == 'PS3TrophiesInstalled_t') return false
    if ($.struct == 'GSStatsUnloaded_t') return false
    return true
  })
}

const out = ['// this file is autogenerated by generate.js - https://github.com/menduz/zig-steamworks']

out.push(`const std = @import("std");`)
out.push(`const builtin = @import("builtin");`)

out.push(`pub const CGameID = u64;`)
out.push(`pub const default_alignment = 1;`)
out.push(`pub const CSteamID = u64;`)
out.push(`pub const intptr_t = ?*anyopaque;`)
out.push(`pub const size_t = isize;`)
out.push(`pub const SteamAPIWarningMessageHook_t = ${convertType(`void (*)(int, const char *)`)};`)
out.push(`pub const SteamAPI_CheckCallbackRegistered_t = ${convertType(`void (*)(int)`)};`)
out.push(`pub const SteamDatagramRelayAuthTicket = ?*anyopaque;`)
out.push(`pub const ISteamNetworkingConnectionSignaling = ?*anyopaque;`)
out.push(`pub const ISteamNetworkingSignalingRecvContext = ?*anyopaque;`)

out.push(`

/// SteamAPI_Init must be called before using any other API functions. If it fails, an
/// error message will be output to the debugger (or stderr) with further information.
pub extern fn SteamAPI_Init() callconv(.C) bool;

/// SteamAPI_Shutdown should be called during process shutdown if possible.
pub extern fn SteamAPI_Shutdown() callconv(.C) void;

pub extern fn SteamAPI_GetHSteamPipe() callconv(.C) HSteamPipe;
pub extern fn SteamAPI_GetHSteamUser() callconv(.C) HSteamPipe;
pub extern fn SteamGameServer_GetHSteamPipe() callconv(.C) HSteamPipe;
pub extern fn SteamGameServer_GetHSteamUser() callconv(.C) HSteamPipe;

// SteamAPI_RestartAppIfNecessary ensures that your executable was launched through Steam.
//
// Returns true if the current process should terminate. Steam is now re-launching your application.
//
// Returns false if no action needs to be taken. This means that your executable was started through
// the Steam client, or a steam_appid.txt file is present in your game's directory (for development).
// Your current process should continue if false is returned.
//
// NOTE: If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary
// since the DRM wrapper will ensure that your application was launched properly through Steam.
pub extern fn SteamAPI_RestartAppIfNecessary( unOwnAppID: u32 ) callconv(.C) bool;

// Many Steam API functions allocate a small amount of thread-local memory for parameter storage.
// SteamAPI_ReleaseCurrentThreadMemory() will free API memory associated with the calling thread.
// This function is also called automatically by SteamAPI_RunCallbacks(), so a single-threaded
// program never needs to explicitly call this function.
pub extern fn SteamAPI_ReleaseCurrentThreadMemory() callconv(.C) void;


// crash dump recording functions
//pub extern fn SteamAPI_WriteMiniDump( uint32 uStructuredExceptionCode, void* pvExceptionInfo, uint32 uBuildID ) callconv(.C) void;
//pub extern fn SteamAPI_SetMiniDumpComment( const char *pchMsg ) callconv(.C) void;

//----------------------------------------------------------------------------------------------------------------------------------------------------------//
//	steamclient.dll private wrapper functions
//
//	The following functions are part of abstracting API access to the steamclient.dll, but should only be used in very specific cases
//----------------------------------------------------------------------------------------------------------------------------------------------------------//

/// SteamAPI_IsSteamRunning() returns true if Steam is currently running
pub extern fn SteamAPI_IsSteamRunning() callconv(.C) bool;

/// sets whether or not Steam_RunCallbacks() should do a try {} catch (...) {} around calls to issuing callbacks
/// This is ignored if you are using the manual callback dispatch method
pub extern fn SteamAPI_SetTryCatchCallbacks( bTryCatchCallbacks: bool ) callconv(.C) void;

/// Inform the API that you wish to use manual event dispatch.  This must be called after SteamAPI_Init, but before
/// you use any of the other manual dispatch functions below.
pub extern fn SteamAPI_ManualDispatch_Init() callconv(.C) void;

/// Perform certain periodic actions that need to be performed.
pub extern fn SteamAPI_ManualDispatch_RunFrame(hSteamPipe: HSteamPipe) callconv(.C) void;

/// Internal structure used in manual callback dispatch
pub const CallbackMsg_t = extern struct  {
  /// Specific user to whom this callback applies.
	m_hSteamUser: HSteamUser,
	/// Callback identifier.  (Corresponds to the k_iCallback enum in the callback structure.)
  m_iCallback: c_int,
  /// Points to the callback structure
	m_pubParam: [*c]u8,
  /// Size of the data pointed to by m_pubParam
	m_cubParam: c_uint,

  pub fn data(self: *const @This()) ?CallbackUnion {
    return switch(self.m_iCallback) {
      ${data.callback_structs.map(_ => `${_.callback_id} => .{ .${_.struct.replace(/_t$/, '')} = from_callback(${_.struct}, self) },`).join('\n')}
      else => blk: {
        if (builtin.mode == .Debug) {
          std.log.warn("STEAM CALLBACK: Unknown callback callback:{any} {s}", .{ self.*, std.fmt.fmtSliceHexLower(self.*.m_pubParam[0..self.*.m_cubParam]) });
        }
        break :blk null;
      },
    };
  }
};

pub const CallbackEnum = enum {
  ${data.callback_structs.map(_ => `${_.struct.replace(/_t$/, '')},`).join('\n')}
};

pub const CallbackUnion = union(CallbackEnum) {
  ${data.callback_structs.map(_ => `${_.struct.replace(/_t$/, '')}: ${_.struct},`).join('\n')} 
};

fn from_callback(comptime T: anytype, callback: *const CallbackMsg_t) T {
  return from_slice(T, callback.*.m_pubParam[0..callback.*.m_cubParam]);
}

pub fn from_slice(comptime T: anytype, slice: []const u8) T {
  var ret: T = std.mem.zeroes(T);
  var retP = &ret;

  const struct_info = @typeInfo(T).Struct;
  var start: usize = 0;
  if (struct_info.layout == .Extern) {
      inline for (struct_info.fields) |field| {
          if (!field.is_comptime) {
              const end = start + @sizeOf(field.type);
              if (end > slice.len) @panic("overflow");
              @memcpy(std.mem.asBytes(&@field(ret, field.name)), slice[start..end]);
              start = end;
          }
      }

      if (!std.mem.eql(u8, std.mem.asBytes(retP), slice)) {
          std.debug.print("  Final serializations:\\n     struct: {}\\n    message: {}\\n           : {any}\\n", .{
              std.fmt.fmtSliceHexLower(std.mem.asBytes(retP)),
              std.fmt.fmtSliceHexLower(slice),
              ret,
          });
      }
  } else {
      @compileLog(T);
      @compileError("Not extern");
  }

  return ret;
}

test {
  @setEvalBranchQuota(1_000_000);
  std.testing.refAllDeclsRecursive(@This());
}

pub const DigitalAnalogAction_t = extern struct {
  actionHandle: InputAnalogActionHandle_t,
  analogActionData: InputAnalogActionData_t,
};

/// Fetch the next pending callback on the given pipe, if any.  If a callback is available, true is returned
/// and the structure is populated.  In this case, you MUST call SteamAPI_ManualDispatch_FreeLastCallback
/// (after dispatching the callback) before calling SteamAPI_ManualDispatch_GetNextCallback again.
pub extern fn SteamAPI_ManualDispatch_GetNextCallback(hSteamPipe: HSteamPipe, pCallbackMsg: [*c]CallbackMsg_t) callconv(.C) bool;

/// You must call this after dispatching the callback, if SteamAPI_ManualDispatch_GetNextCallback returns true.
pub extern fn SteamAPI_ManualDispatch_FreeLastCallback(hSteamPipe: HSteamPipe) callconv(.C) void;

/// Return the call result for the specified call on the specified pipe.  You really should
/// only call this in a handler for SteamAPICallCompleted_t callback.
pub extern fn SteamAPI_ManualDispatch_GetAPICallResult(hSteamPipe: HSteamPipe, hSteamAPICall: SteamAPICall_t, result: [*c]u8, size: u32, iCallbackExpected: i32, pbFailed: *bool) bool;

extern fn CustomSteamClientGetter() callconv(.C) [*c]ISteamClient;
pub fn SteamClient() ISteamClient {
  return ISteamClient{ .ptr = CustomSteamClientGetter() };
}
`)

out.push(`\n// Typedefs`)
data.typedefs.forEach(t => {
  out.push(`pub const ${t.typedef} = ${convertType(t.type)};`)
})

out.push(`\n// Callbacks`)
data.callback_structs.forEach(_ => {
  out.push(`/// callbackId = ${_.callback_id}`)
  printStruct(_)
})

printConsts(data.consts);
function printConsts(list) {
  out.push(`\n// Constants`)
  list.forEach(_ => {
    const val = _.constval === '0xffffffffffffffffull' ? '0xffffffffffffffff' : _.constval

    if (_.constname == 'HSERVERQUERY_INVALID')
      return out.push(`pub const ${_.constname} = ${val}; `)

    switch (_.constname) {
      case 'k_SteamDatagramPOPID_dev':
      case 'k_SteamItemInstanceIDInvalid':
        return out.push(`// TODO: fix the next line declaration\n// pub const ${_.constname}: ${convertType(_.consttype)} = ${_.constval};`)
    }


    return out.push(`pub const ${_.constname}: ${convertType(_.consttype)} = ${val}; `)
  })
}

function getDefaultValue(typeName, internalType) {
  const enums = [...data.enums, ...(internalType?.enums ?? [])]
  const isEnum = enums.find($ => $.enumname == typeName)
  if (isEnum) {
    const zero = isEnum.values.find($ => parseInt($.value) === 0)
    if (zero) {
      return `${typeName}.${zero.name}`
    }
  }

  switch (typeName) {
    case 'bool': return false
    case 'u8':
    case 'u8':
    case 'i8':
    case 'i16':
    case 'u16':
    case 'i32':
    case 'u32':
    case 'i64':
    case 'u64':
    case 'f32':
    case 'f64':
    case 'isize':
    case 'usize':
    case 'c_uint':
    case 'c_int':
      return '0'
    case '?*anyopaque':
    case '?*const anyopaque':
    case '[*c]u8':
    case '[*c]const u8':
    case '[*c][*c]const u8':
    case '*const anyopaque':
      return 'null'
  }

  const isTypedef = data.typedefs.find($ => $.typedef == typeName)

  if (isTypedef) {
    return getDefaultValue(convertType(isTypedef.type), internalType)
  }
}

function printEnums(enums) {
  enums.length && out.push(`\n// Enums`)
  enums.forEach(_ => {
    const typename = `${_.enumname}`
    out.push(`\npub const ${typename} = enum(c_int) {`)

    _.values.forEach($ => {
      const totalValues = _.values.filter(item => item.value == $.value)
      const isFirst = totalValues.length == 1 || totalValues[0].name == $.name

      if (isFirst)
        out.push(`${$.name} = ${$.value},`)

    })

    out.push(`};`)
  })
}

printEnums(data.enums)

function printStructMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = getParams(_.params)

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: *Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['@ptrCast(?*anyopaque, self)', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function printMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = getParams(_.params)

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['self.ptr', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function printMethods(structName, data) {
  if (data && data.length) {
    out.push(`// methods`)
    out.push(`const Self = @This();`)
    data.forEach(_ => {
      const originalParams = getParams(_.params)

      const [, fnName] = _.methodname_flat.split(structName + '_')

      if (fnName && /^[a-z0-9_]+$/i.test(fnName)) {
        out.push(`pub fn ${fnName}(${['self: Self', ...originalParams].join(', ')}) ${convertType(_.returntype)} {`)
        out.push(` return ${_.methodname_flat}(${['self.ptr', ..._.params.map(p => paramName(p.paramname))].join(', ')});`)
        out.push(`}\n`)
      }
    })
  }
}

function paramName(p) {
  switch (p) {
    case "type":
      return '_type'
  } return p
}

function getParams(params) {
  return params.map(p => {
    const n = paramName(p.paramname)
    const t = convertType(p.paramtype, true)

    if (t == 'SteamNetworkingErrMsg')
      return `${n}: [*c]u8`

    return `${n}: ${t}`
  })
}

function printFns(structName, data) {
  if (data && data.length) {
    out.push(`\n// static functions`)
    data.forEach(_ => {
      const self = `self: ?*anyopaque`

      const originalParams = getParams(_.params)

      const params = [
        self,
        ...originalParams
      ]

      out.push(`extern fn ${_.methodname_flat}(${params.join(', ')}) callconv(.C) ${convertType(_.returntype, true)};`)
    })
  }
}



function printStruct(struct) {
  const structName = struct.struct;
  out.push(`pub const ${structName} = extern struct {`)

  struct.fields.forEach(_ => {
    const type = convertType(_.fieldtype)
    const val = getDefaultValue(type, struct)


    const alignment = structName in g_CustomPackSize ? `align(${g_CustomPackSize[structName]})` : `align(default_alignment)`; // https://github.com/ziglang/zig/issues/16633
    out.push(`  ${_.fieldname}: ${convertType(_.fieldtype)} ${alignment} ${val !== undefined ? '=' + val : ''},`)
  });

  struct.consts && printConsts(struct.consts);
  struct.enums && printEnums(struct.enums)

  printStructMethods(structName, struct.methods)

  out.push('};')
  printFns(structName, struct.methods)
}

out.push(`\n// Structs`)
data.structs.forEach(printStruct)

out.push(`\n// Interfaces`)

data.interfaces.forEach(_ => {

  _.accessors?.forEach(a => {
    out.push(`extern fn ${a.name_flat}() callconv(.C) [*c]${_.classname};`)

    out.push(`/// ${a.kind}`)
    out.push(`pub fn ${a.name}() ${_.classname} {`)
    out.push(`  return ${_.classname}{ .ptr = ${a.name_flat}() };`)
    out.push(`}`)
  })


  out.push(`\npub const ${_.classname} = extern struct {`)
  out.push(`ptr: ?*anyopaque,`)

  _.enums && printEnums(_.enums)
  printMethods(_.classname, _.methods)
  out.push('};')
  printFns(_.classname, _.methods)
})

function convertType(t, isFnSignature) {
  if (t === undefined) return ''

  if (t && t.startsWith('void (*)')) {
    const middle = /\(([^\(]*)\)$/.exec(t)
    const types = middle ? middle[1].split(/\s*,\s*/g) : []
    return `?*const fn (${types.map(_ => convertType(_, true)).join(',')}) callconv(.C) void`
  }

  { // char[123]
    const slice = /([a-z0-9_]+)\s*\[(\d+)\]/i
    const r = slice.exec(t)
    if (r) {
      // const size slices are incompatible with callconv(.C), use a regular poinnter instead.
      // the caller must ensure the pointer has the right size
      if (isFnSignature)
        return `[*c]${convertType(r[1])}`

      return `[${r[2]}]${convertType(r[1])}`
    }
  }
  switch (t) {
    case 'char': return 'u8';
    case 'unsigned char': return 'u8';
    case 'signed char': return 'i8';
    case 'short': return 'i16';
    case 'unsigned short': return 'u16';
    case 'int': return 'i32';
    case 'int32_t': return 'i32';
    case 'unsigned int': return 'u32';
    case 'long long': return 'i64';
    case 'int64_t': return 'i64';
    case 'unsigned long long': return 'u64';
    case 'void *': return '?*anyopaque';
    case 'const void *': return '?*const anyopaque';
    case 'char *': return '[*c]u8'
    case 'float': return 'f32'
    case 'double': return 'f64'
    case 'const char *': return '[*c]const u8'
    case 'const char **': return '[*c][*c]const u8'
    case 'SteamInputActionEvent_t::AnalogAction_t': return 'DigitalAnalogAction_t'
    case 'RequestPlayersForGameResultCallback_t::PlayerAcceptState_t':
      return 'c_int'

    case 'const ScePadTriggerEffectParam *':
      return '*const anyopaque'

    case 'ISteamHTMLSurface::EHTMLMouseButton':
    case 'ISteamHTMLSurface::EHTMLKeyModifiers':
      return 'c_int'
  }

  if (data.enums.some(_ => _.enumname === t))
    return `${t}`;
  { // const servernetadr_t *
    const slice = /^const ([0-9a-z_]+)\s*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]const ${convertType(r[1])}`
    }
  }
  { // servernetadr_t *const*
    const slice = /([0-9a-z_]+)\s*\*\s?const\s?\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]const [*c] ${convertType(r[1])}`
    }
  }
  { // servernetadr_t **
    const slice = /^([0-9a-z_]+)\s*\*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c][*c] ${convertType(r[1])}`
    }
  }
  { //const servernetadr_t &
    const slice = /^const ([0-9a-z_]+)\s*&$/i
    const r = slice.exec(t)
    if (r) {
      return `${convertType(r[1])}`
    }
  }
  { //servernetadr_t &
    const slice = /^([0-9a-z_]+)\s*&$/i
    const r = slice.exec(t)
    if (r) {
      return `${convertType(r[1])}`
    }
  }
  { // servernetadr_t *
    const slice = /^([0-9a-z_]+)\s*\*$/i
    const r = slice.exec(t)
    if (r) {
      return `[*c]${convertType(r[1])}`
    }
  }
  return t;
}

fs.writeFileSync(outFile, out.join('\n'))
fs.writeFileSync(outFileCpp, cpp.join('\n'))